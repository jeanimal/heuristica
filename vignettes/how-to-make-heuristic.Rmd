---
title: "How to make your own heuristic"
author: "Jean Whitmore"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

So you have your own idea for a heuristic.  Just implement a few functions and you can run
comparisons with heuristica's heuristics.

## Installation

To get the github version of heuristica:

```{r}
# Uncomment and execute install functions you may need.
# install.packages("devtools") 
# Uncomment and execute 
# install.packages("heuristica") 
#    -- OR --
# devtools::install_github("jeanimal/heuristica")
#    -- OR --
devtools::load_all()
library("heuristica")
```

## Minimal model

### Fitting function

First, write a function to fit data.  It must have three required arguments, but then you can have as many optional arguments as you want.  The required arguments are:
* train_data.  This is the data to train on and can be either a matrix or data.frame
* criterion_col.  The index of the criterion column, the "Y" in a regression.
* cols_to_fit.  A vector of indexes of columns to fit, the "X's" in a regression.

This function should output a structure with several elements:
* criterion_col for heuristica to use
* cols_to_fit for heuristica to use
* A class name the same as your function name, "myModel" in this case.
* Any information your predictor function will need, such as fitted parameters
So let's see a bare bones example.

```{r}
myModel <- function(train_data, criterion_col, cols_to_fit) {
  # We will fill in a more interesting version below.
  structure(list(criterion_col=criterion_col, cols_to_fit=cols_to_fit),
            class="myModel")
}
```

The class name will tell heuristica how to find the predicting function.  But if you are curious, you can read more about classes at __.

### Predicting function

To make predictions with heuristica, implement a function called predictRoot, then a dot, then your class name.  Inputs:
* object, which will have everything returned by your fitting function
* row1, one row of a matrix or data.frame having just the columns in cols_to_fit
* row2, another row of a matrix or data.frame having just the columns in cols_to_fit
The output should be:
* A value from 0 to 1, the probability that row1's criterion is greater than row2's criterion.

For our bare-bones example, we will randomly guess 0 or 1.  1 means we predict the criterion in row1 will be greater.  0 means we predict the criterion in row2 will be greter.

```{r}
predictRoot.myModel <- function(object, row1, row2) {
  return(sample(c(0,1), 1))
}
```

### Using the new model

Let's consider a subset of the high school dropout data included with this package.  This subset has 5 schools.  The first column has the school name.  The drop-out rates are in column 2, and we will fit them using columns 3-5, namely Enrollment, Attendance Rate, and Low Income Students.
```{r}
data("highschool_dropout")
schools <- highschool_dropout[c(1:5), c(1,4,6,7,11)]
schools
```

To analyze our heurist on this data requires these steps:
1. "Fit" myModel to the schools data, which in this case does nothing.
2. Ask the model to predict the probability that Austin has a higher dropout rate than Farrgut (the first two schools in our data).

```{r}
myFit <- myModel(schools, 2, c(3:5))
row1 <- oneRow(schools, 1)
row1
row2 <- oneRow(schools, 2)
row2
predictRowPair(row1, row2, myFit)
```

We can see in the original data.frame that Austin had the higher dropout rate, meaning 1.0 would have been correct output.  We can get heuristica to show this using a more general rowPair function to view the correct probability based on the criterion, which will be 0 or 1.  (An exception is when the criterion is equal for both values, in which case the correct output is defined as 0.5.)
```{r}
myFit <- myModel(schools, 2, c(3:5))
rowPairApply(oneRow(schools, 1), oneRow(schools, 2), criterion(2), heuristics(myFit))
```

Heuristica makes this sort of assessment easy-- it can check your model against all row pairs and calculate the percent correct.  Here we do myModel for all pairs of schools in our subset data.  Not surprisingly, it earns roughly 50% correct.
```{r}
myFit <- myModel(schools, 2, c(3:5))
pctCorrectOfPredictPair(list(myFit), schools)
```


