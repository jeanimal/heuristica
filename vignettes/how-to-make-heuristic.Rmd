---
title: "How to make your own heuristic"
author: "Jean Whitmore"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

So you have your own idea for a heuristic.  Just implement a few functions and you can run
comparisons with heuristica's heuristics.

## Installation

To get the github version of heuristica:

```{r}
# Uncomment and execute install functions you may need.
# install.packages("devtools") 
# Uncomment and execute 
# install.packages("heuristica") 
#    -- OR --
# devtools::install_github("jeanimal/heuristica")
#    -- OR --
# devtools::load_all()
library("heuristica")
```

## Minimal model

### Fitting function

First, write a function to fit data.  It must have three required arguments, but then you can have as many optional arguments as you want.  The required arguments are:
* train_data.  This is the data to train on and can be either a matrix or data.frame
* criterion_col.  The index of the criterion column, the "Y" in a regression.
* cols_to_fit.  A vector of indexes of columns to fit, the "X's" in a regression.

This function should output a structure with several elements:
* criterion_col for heuristica to use
* cols_to_fit for heuristica to use
* A class name the same as your function name, "myModel" in this case.
* Any information your predictor function will need, such as fitted parameters
So let's see a bare bones example.

```{r}
myModel <- function(train_data, criterion_col, cols_to_fit) {
  # We will fill in a more interesting version below.
  structure(list(criterion_col=criterion_col, cols_to_fit=cols_to_fit),
            class="myModel")
}
```

The class name will tell heuristica how to find the predicting function.  But if you are curious, you can read more about classes at __.

### Predicting function

To make predictions with heuristica, implement a function called predictRoot, then a dot, then your class name.  Inputs:
* object, which will have everything returned by your fitting function
* row1, one row of a matrix or data.frame having just the columns in cols_to_fit
* row2, another row of a matrix or data.frame having just the columns in cols_to_fit
The output should be:
* A value from 0 to 1, the probability that row1's criterion is greater than row2's criterion.

For our bare-bones example, we will just always return 0.5, meaning we always predict row1 is
just as likely to have a greater criterion as row2.

```{r}
predictRoot.myModel <- function(object, row1, row2) {
  return(0.5)
}
```

### Using the new model

Let's consider a subset of the high school dropout data included with this package.  This subset has 5 schools.  The first column has the school name.  The drop-out rates are in column 2, and we will fit them using columns 3-5, namely Enrollment, Attendance Rate, and Low Income Students.
```{r}
data("highschool_dropout")
schools <- highschool_dropout[c(1:5), c(1,4,6,7,11)]
schools
```

  We "fit" myModel to the schools data.  Then we extract two rows to compare, which happen to be Austin and Farrgut.  Finally we ask the model to predict the probability that Austin has the higher drop-out rate, and of course it answers 0.5, because that's how we hard-coded it.

```{r}
myFit <- myModel(schools, 2, c(3:5))
row1 <- oneRow(schools, 1)
row1
row2 <- oneRow(schools, 2)
row2
predictRowPair(row1, row2, myFit)
```

We can see in the data that Austin was the correct answer, meaning 1.0 would have been correct output.  We can use a more general rowPair function to view the correct probability based on the criterion, which will be 0 or 1.  (An exception is when the criterion is equal for both values, in which case the correct output is defined as 0.5.)
```{r}
myFit <- myModel(schools, 2, c(3:5))
rowPairApply(oneRow(schools, 1), oneRow(schools, 2), criterion(2), heuristics(myFit))
```

We can use this model to generate predictions for all pairs of schools and then calculate the percent correct it gets.  Not surprisingly, this is 50%.
```{r}
myFit <- myModel(schools, 2, c(3:5))
pctCorrectOfPredictPair(list(myFit), schools)
```